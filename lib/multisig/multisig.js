var Signing = require('../crypto/signing');
var Converter = require('../crypto/converter');
var Curl = require('../crypto/curl');
var Bundle = require('../crypto/bundle');
var Utils = require('../utils/utils');
var inputValidator = require('../utils/inputValidator');
var errors = require('../errors/inputErrors');


function Multisig(provider) {

    this._makeRequest = provider;
}

/**
*   Gets the key value of a seed
*
*   @method getKey
*   @param {string} seed
*   @param {int} index
*   @returns {string} digest trytes
**/
Multisig.prototype.getKey = function(seed, index, security) {

    return Converter.trytes(Signing.key(Converter.trits(seed), index, security));
}

/**
*   Gets the digest value of a seed
*
*   @method getDigest
*   @param {string} seed
*   @param {int} index
*   @returns {string} digest trytes
**/
Multisig.prototype.getDigest = function(seed, index) {

    var key = Signing.key(Converter.trits(seed), index, security);
    return Converter.trytes(Signing.digests(key));
}

/**
*   Initiates the generation of a new multisig address or adds the key digest to an existing one
*
*   @method addAddressDigest
*   @param {string} digestTrytes
*   @param {string} curlStateTrytes
*   @returns {String}
**/
Multisig.prototype.addAddressDigest = function(digestTrytes, curlStateTrytes) {

    var digest = Converter.trits(digestTrytes);

    // If curlStateTrytes is provided, convert into trits
    // else use empty state and initiate the creation of a new address
    var curlState = curlStateTrytes ? Converter.trits(curlStateTrytes) : [];

    var curl = new Curl();

    // initialize Curl with the provided state
    curl.initialize(curlState);
    // absorb the key digest
    curl.absorb(digest);

    return Converter.trytes(curl.state);
}

/**
*   Generates a new address
*
*   @method finalizeAddress
*   @param {string} curlStateTrytes
*   @param {string}
*   @returns {String} address
**/
Multisig.prototype.finalizeAddress = function(curlStateTrytes) {

    var curlState = Converter.trits(curlStateTrytes);

    var curl = new Curl();

    // initialize Curl with the provided state
    curl.initialize(curlState);

    var addressTrits = [];
    curl.squeeze(addressTrits);

    // Convert trits into trytes and return the address
    return Converter.trytes(addressTrits);
}

/**
*   Validates  a generated multisig address
*
*   @method validateAddress
*   @param {string} multisigAddress
*   @param {array} digests
*   @returns {bool}
**/
Multisig.prototype.validateAddress = function(multisigAddress, digests) {

    var curl = new Curl();

    // initialize Curl with the provided state
    curl.initialize();

    digests.forEach(function(keyDigest) {
        curl.absorb(Converter.trits(keyDigest));
    })

    var addressTrits = [];
    curl.squeeze(addressTrits);

    // Convert trits into trytes and return the address
    return Converter.trytes(addressTrits) === multisigAddress;
}


/**
*   Prepares transfer by generating the bundle with the corresponding cosigner transactions
*   Does not contain signatures
*
*   @method initiateTransfer
*   @param {string || array} multisigInputs string or array of input addresses
*   @param {string} remainderAddress Has to be generated by the cosigners before initiating the transfer, can be null if fully spent
*   @param {int} numCosigners total number of multisig signers
*   @param {object} transfers
*   @param {function} callback
*   @returns {array} Array of transaction objects
**/
Multisig.prototype.initiateTransfer = function( multisigInputs, remainderAddress, numCosigners, transfers, callback ) {

    var self = this;

    // If message or tag is not supplied, provide it
    // Also remove the checksum of the address if it's there
    transfers.forEach(function(thisTransfer) {
        thisTransfer.message = thisTransfer.message ? thisTransfer.message : '';
        thisTransfer.tag = thisTransfer.tag ? thisTransfer.tag : '';
        thisTransfer.address = Utils.noChecksum(thisTransfer.address);
    })

    // Input validation of transfers object
    if (!inputValidator.isTransfersArray(transfers)) {
        return callback(errors.invalidTransfers());
    }

    // If single input provided, convert into array
    if (inputValidator.isString(multisigInputs)) multisigInputs = array(multisigInputs);

    // validate inputs
    if (!inputValidator.isArrayOfHashes(multisigInputs)) {
        return callback(errors.invalidInputs());
    }

    // validate remainder address
    if (remainderAddress && !inputValidator.isAddress(remainderAddress)) {
        return callback(errors.invalidTrytes());
    }

    // Create a new bundle
    var bundle = new Bundle();

    var totalValue = 0;
    var signatureFragments = [];
    var tag;

    //
    //  Iterate over all transfers, get totalValue
    //  and prepare the signatureFragments, message and tag
    //
    for (var i = 0; i < transfers.length; i++) {

        var signatureMessageLength = 1;

        // If message longer than 2187 trytes, increase signatureMessageLength (add multiple transactions)
        if (transfers[i].message.length > 2187) {

            // Get total length, message / maxLength (2187 trytes)
            signatureMessageLength += Math.floor(transfers[i].message.length / 2187);

            var msgCopy = transfers[i].message;

            // While there is still a message, copy it
            while (msgCopy) {

                var fragment = msgCopy.slice(0, 2187);
                msgCopy = msgCopy.slice(2187, msgCopy.length);

                // Pad remainder of fragment
                for (var j = 0; fragment.length < 2187; j++) {
                    fragment += '9';
                }

                signatureFragments.push(fragment);
            }

        } else {
            // Else, get single fragment with 2187 of 9's trytes
            var fragment = '';

            if (transfers[i].message) {
                fragment = transfers[i].message.slice(0, 2187)
            }

            for (var j = 0; fragment.length < 2187; j++) {
                fragment += '9';
            }

            signatureFragments.push(fragment);
        }

        // get current timestamp in seconds
        var timestamp = Math.floor(Date.now() / 1000);

        // If no tag defined, get 27 tryte tag.
        tag = transfers[i].tag ? transfers[i].tag : '999999999999999999999999999';

        // Pad for required 27 tryte length
        for (var j = 0; tag.length < 27; j++) {
            tag += '9';
        }

        // Add first entries to the bundle
        // Slice the address in case the user provided a checksummed one
        bundle.addEntry(signatureMessageLength, transfers[i].address.slice(0, 81), transfers[i].value, tag, timestamp)
        // Sum up total value
        totalValue += parseInt(transfers[i].value);
    }

    // Get inputs if we are sending tokens
    if (totalValue) {

        var command = {
            'command': 'getBalances',
            'addresses': multisigInputs,
            'threshold': 100
        }

        self._makeRequest.send(command, function(e, balances) {

            var totalBalance = 0;

            for (var i = 0; i < balances.length; i++) {

                var thisBalance = balances[i];

                if (thisBalance > 0) {

                    var toSubtract = 0 - thisBalance;
                    var timestamp = Math.floor(Date.now() / 1000);
                    totalBalance += thisBalance;

                    // Add input as bundle entry
                    // Only a single entry, signatures will be added later
                    bundle.addEntry(1, inputAddress, toSubtract, tag, timestamp);

                    // if we've already reached the intended input value, break out of loop
                    if (totalBalance >= totalValue) {
                        console.log("Total balance already reached ")
                        break;
                    }
                }

            }

            if (totalValue > totalBalance) {
                return callback(new Error("Not enough balance."));
            }


            // If there is a remainder value
            // Add extra output to send remaining funds to
            if (totalBalance > totalValue) {

                var remainder = totalBalance - totalValue;

                // Remainder bundle entry if necessary
                if (!remainderAddress) {
                    return callback(new Error("No remainder address defined"));
                }

                bundle.addEntry(1, remainderAddress, remainder, tag, timestamp);
            }


            // If no input required, don't sign and simply finalize the bundle
            bundle.finalize();
            bundle.addTrytes(signatureFragments);

            return callback(null, bundle.bundle);
        })

    } else {

        throw new Error("Invalid value transfer: the transfer does not require a signature.");
    }

}


/**
*   Adds the cosigner signatures to the corresponding bundle transaction
*
*   @method addSignature
*   @param {array} bundleToSign
*   @param {int} cosignerIndex
*   @param {string} inputAddress
*   @param {string} key
*   @param {function} callback
*   @returns {array} trytes Returns bundle trytes
**/
Multisig.prototype.addSignature = function(bundleToSign, cosignerIndex, inputAddress, key, callback) {

    var bundle = new Bundle();
    bundle.bundle = bundleToSign;

    var key = Converter.trits(key);

    //  SIGNING OF INPUTS
    //
    //  Here we do the actual signing of the inputs
    //  Iterate over all bundle transactions, find the inputs
    //  Get the corresponding private key and calculate the signatureFragment
    for (var i = 0; i < bundle.bundle.length; i++) {

        if (bundle.bundle[i].value < 0 && bundle.bundle[i].address === inputAddress) {

            var bundleEntryToSign = i + (cosignerIndex * 2);
            var thisAddress = bundle.bundle[bundleEntryToSign].address;
            var bundleHash = bundle.bundle[bundleEntryToSign].bundle;

            //  First 6561 trits for the firstFragment
            var firstFragment = key.slice(0, 6561);

            //  Get the normalized bundle hash
            var normalizedBundleHash = bundle.normalizedBundle(bundleHash);
            var normalizedBundleFragments = [];

            // Split hash into 3 fragments
            for (var i = 0; i < 3; i++) {
                normalizedBundleFragments[i] = normalizedBundleHash.slice(i * 27, (i + 1) * 27);
            }

            //  First bundle fragment uses 27 trytes
            var firstBundleFragment = normalizedBundleFragments[(cosignerIndex * 2) % 3];

            //  Calculate the new signatureFragment with the first bundle fragment
            var firstSignedFragment = Signing.signatureFragment(firstBundleFragment, firstFragment);


            //  Convert signature to trytes and assign the new signatureFragment
            bundle.bundle[bundleEntryToSign].signatureMessageFragment = Converter.trytes(firstSignedFragment);

            //  Because the signature is > 2187 trytes, we need to
            //  find the second transaction to add the remainder of the signature
            if (bundle.bundle[bundleEntryToSign + 1].address === inputAddress && bundle.bundle[bundleEntryToSign + 1].value === 0) {

                // Use the second 6562 trits
                var secondFragment = key.slice(6561,  2 * 6561);

                // The second 27 to 54 trytes of the bundle hash
                var secondBundleFragment = normalizedBundleFragments[(cosignerIndex * 2 + 1) % 3];

                //  Calculate the new signature
                var secondSignedFragment = Signing.signatureFragment(secondBundleFragment, secondFragment);

                //  Convert signature to trytes and assign it again to this bundle entry
                bundle.bundle[bundleEntryToSign + 1].signatureMessageFragment = Converter.trytes(secondSignedFragment);

                // Exit the for loop
                break;
            }
        }
    }

    return callback(null, bundle.bundle);
}

/**
*   Validates the signatures
*
*   @method validateSignatures
*   @param {array} signedBundle
*   @param {string} inputAddress
*   @param {int} numCosigners
*   @returns {bool}
**/
Multisig.prototype.validateSignatures = function(signedBundle, inputAddress, numCosigners) {


    var bundleHash;
    var signatureFragments = [];

    for (var i = 0; i < signedBundle.length; i++) {

        if (signedBundle[i].value < 0 && signedBundle[i].address === inputAddress) {

            bundleHash = signedBundle[i].bundle;

            for (var j = 0; j < numCosigners * 2; j++) {

                signatureFragments.push(signedBundle[j + i].signatureMessageFragment)
            }

            break;
        }
    }

    return Signing.validateSignatures(inputAddress, signatureFragments, bundleHash);
}

module.exports = Multisig;
