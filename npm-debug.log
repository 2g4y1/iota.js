0 info it worked if it ends with ok
1 verbose cli [ '/usr/local/bin/node', '/usr/local/bin/npm', 'publish' ]
2 info using npm@3.9.5
3 info using node@v4.2.1
4 verbose publish [ '.' ]
5 silly cache add args [ '.', null ]
6 verbose cache add spec .
7 silly cache add parsed spec Result {
7 silly cache add   raw: '.',
7 silly cache add   scope: null,
7 silly cache add   name: null,
7 silly cache add   rawSpec: '.',
7 silly cache add   spec: '/Users/domsch/Desktop/IOTA/iota.lib.js',
7 silly cache add   type: 'directory' }
8 verbose addLocalDirectory /Users/domsch/.npm/iota.lib.js/0.0.11/package.tgz not in flight; packing
9 verbose correctMkdir /Users/domsch/.npm correctMkdir not in flight; initializing
10 info lifecycle iota.lib.js@0.0.11~prepublish: iota.lib.js@0.0.11
11 silly lifecycle iota.lib.js@0.0.11~prepublish: no script for prepublish, continuing
12 verbose tar pack [ '/Users/domsch/.npm/iota.lib.js/0.0.11/package.tgz',
12 verbose tar pack   '/Users/domsch/Desktop/IOTA/iota.lib.js' ]
13 verbose tarball /Users/domsch/.npm/iota.lib.js/0.0.11/package.tgz
14 verbose folder /Users/domsch/Desktop/IOTA/iota.lib.js
15 verbose addLocalTarball adding from inside cache /Users/domsch/.npm/iota.lib.js/0.0.11/package.tgz
16 verbose correctMkdir /Users/domsch/.npm correctMkdir not in flight; initializing
17 silly cache afterAdd iota.lib.js@0.0.11
18 verbose afterAdd /Users/domsch/.npm/iota.lib.js/0.0.11/package/package.json not in flight; writing
19 verbose correctMkdir /Users/domsch/.npm correctMkdir not in flight; initializing
20 verbose afterAdd /Users/domsch/.npm/iota.lib.js/0.0.11/package/package.json written
21 silly publish { name: 'iota.lib.js',
21 silly publish   version: '0.0.11',
21 silly publish   description: 'Javascript Library for the IOTA API.',
21 silly publish   main: './lib/iota.js',
21 silly publish   scripts:
21 silly publish    { build: 'gulp',
21 silly publish      test: 'echo "Error: no test specified" && exit 1' },
21 silly publish   author: { name: 'Dominik Schiener', url: 'IOTA Foundation' },
21 silly publish   keywords:
21 silly publish    [ 'iota',
21 silly publish      'tangle',
21 silly publish      'library',
21 silly publish      'browser',
21 silly publish      'javascript',
21 silly publish      'nodejs',
21 silly publish      'API' ],
21 silly publish   license: 'MIT',
21 silly publish   bugs: { url: 'https://github.com/iotaledger/iota.lib.js/issues' },
21 silly publish   repository:
21 silly publish    { type: 'git',
21 silly publish      url: 'git+https://github.com/iotaledger/iota.lib.js.git' },
21 silly publish   dependencies: { async: '^2.1.2', xmlhttprequest: '^1.8.0' },
21 silly publish   devDependencies:
21 silly publish    { bower: '^1.8.0',
21 silly publish      browserify: '^13.1.1',
21 silly publish      del: '^2.2.2',
21 silly publish      gulp: '^3.9.1',
21 silly publish      'gulp-jshint': '^2.0.2',
21 silly publish      'gulp-rename': '^1.2.2',
21 silly publish      'gulp-replace': '^0.5.4',
21 silly publish      'gulp-uglify': '^2.0.0',
21 silly publish      jshint: '^2.9.4',
21 silly publish      'vinyl-buffer': '^1.0.0',
21 silly publish      'vinyl-source-stream': '^1.1.0' },
21 silly publish   readme: '# IOTA Javascript LIBRARY\n\nThis is the official Javascript library for the IOTA Core. It implements both the [official API](https://iota.readme.io/), as well as newly proposed functionality (such as signing, bundles, utilities and conversion).\n\nIt should be noted that the Javascript Library as it stands right now is an **early beta release**. As such, there might be some unexpected results. Please join the community (see links below) and post [issues on here](https://github.com/iotaledger/iota.lib.js/issues), to ensure that the developers of the library can improve it.\n\n> **Join the Discussion**\n\n> If you want to get involved in the community, need help with getting setup, have any issues related with the library or just want to discuss Blockchain, Distributed Ledgers and IoT with other people, feel free to join our Slack. [Slack](http://slack.iotatoken.com/) You can also ask questions on our dedicated forum at: [IOTA Forum](http://forum.iotatoken.com/).\n\n## Installation\n\n### Node.js\n\n```\nnpm install iota.lib.js\n```\n\n### Bower\n\n```\nbower install iota.lib.js\n```\n\nOnce you\'ve built the dist with gulp, you can either use `iota.js` or the minified version `iota.min.js` in the browser.\n\n---\n\n# Documentation\n\nIt should be noted that this is a temporary home for the official documentation. We are currently transitioning to a new developer hub, where we will have a dedicated website for the API documentation with concrete examples. The below documentation should be sufficient in enabling you to get started in the meantime.\n\n\n## Getting Started\n\nAfter you\'ve successfully installed the library, it is fairly easy to get started by simply launching a new instance of the IOTA object. When instantiating the object you have the option to decide the `host` and `port` that are used for sending the requests to, as can be seen in the example below:\n\n```\n// Create IOTA instance\nvar iota = new IOTA({\n    \'host\': \'http://localhost\',\n    \'port\': 14265\n});\n\n// now you can start using all of the functions\niota.api.getNodeInfo();\n```\n\nOverall, there are currently three subclasses that are accessible from the IOTA object:\n- **`api`**: Core API functionality for interacting with the IOTA core.\n- **`utils`**: Utility related functions for conversions, validation and so on  \n- **`validate`**: Validator functions that can help with determining whether the inputs or results that you get are valid.\n\nIn the future new IOTA Core modules (such as Flash, MAM) and all IXI related functionality will be available.\n\n## How to use the Library\n\nIt should be noted that most API calls are done asynchronously. What this means is that you have to utilize callbacks in order to catch the response successfully. We will add support for sync API calls, as well as event listeners in future versions.\n\nHere is a simple example of how to access the `getNodeInfo` function:\n\n```\niota.api.getNodeInfo(function(error, success) {\n    if (error) {\n        console.error(error);\n    } else {\n        console.log(success);\n    }\n})\n```\n\n---\n\n## API Table of Contents\t\t\n\n- **[api](#api)**\n    - **[Standard API](#standard-api)**\n    - **[getTransactionsObjects](#gettransactionsobjects)**\n    - **[findTransactionObjects](#findtransactionobjects)**\n    - **[getLatestInclusion](#getlatestinclusion)**\n    - **[broadcastAndStore](#broadcastandstore)**\n    - **[getNewAddress](#getnewaddress)**\n    - **[getInputs](#getinputs)**\n    - **[prepareTransfers](#preparetransfers)**\n    - **[sendTrytes](#sendtrytes)**\n    - **[sendTransfer](#sendtransfer)**\n    - **[replayBundle](#replaybundle)**\n    - **[broadcastBundle](#broadcastbundle)**\n    - **[getBundle](#getbundle)**\n    - **[getTransfers](#gettransfers)**\n    - **[getAccountData](#getaccountdata)**\n- **[utils](#utils)**\n    - **[convertUnits](#convertunits)**\n    - **[addChecksum](#addchecksum)**\n    - **[noChecksum](#nochecksum)**\n    - **[transactionObject](#transactionobject)**\n    - **[transactionTrytes](#transactiontrytes)**\n    - **[categorizeTransfers](#categorizetransfers)**\n- **[validate](#validate)**\n    - **[isAddress](#isaddress)**\n    - **[isTrytes](#istrytes)**\n    - **[isValue](#isvalue)**\n    - **[isHash](#ishash)**\n    - **[isTransfersArray](#istransfersarray)**\n    - **[isArrayOfHashes](#isarrayofhashes)**\n    - **[isArrayOfTrytes](#isarrayoftrytes)**    \n    - **[isArrayOfAttachedTrytes](#isarrayofattachedtrytes)**\n    - **[isUri](#isuri)**\n    - **[isInputs](#isinputs)**\n    - **[isString](#isstring)**\n    - **[isInt](#isint)**\n    - **[isArray](#isarray)**\n    - **[isObject](#isobject)**\n\n---\n\n## `iota.api`\n\n### `Standard API`\n\nThis Javascript library has implemented all of the core API calls that are made available by the current [IOTA Reference Implementation](https://github.com/iotaledger/iri). For the full documentation of all the Standard API calls, please refer to the official documentation: [official API](https://iota.readme.io/).\n\nYou can simply use any of the available options from the `api` object then. For example, if you want to use the `getTips` function, you would simply do it as such:\n\n```\niota.api.getTips(function(error, success) {\n    // do stuff here\n})\n```\n\n---\n\n### `getTransactionsObjects`\n\nWrapper function for `getTrytes` and the Utility function `transactionObjects`. This function basically returns the entire transaction objects for a list of transaction hashes.\n\n\n#### Input\n```\niota.api.getTransactionsObjects(hashes, callback)\n```\n\n1. **`hashes`**: `Array` List of transaction hashes\n2. **`callback`**: `Function` callback.\n\n#### Return Value\n\n1. **`Array`** - list of all the transaction objects from the corresponding hashes.\n\n---\n\n### `findTransactionObjects`\n\nWrapper function for `getTrytes` and the Utility function `transactionObjects`. This function basically returns the entire transaction objects for a list of transaction hashes.\n\n\n#### Input\n```\niota.api.findTransactionObjects(hashes, callback)\n```\n\n1. **`hashes`**: `Array` List of transaction hashes\n2. **`callback`**: `Function` callback.\n\n#### Return Value\n\n1. **`Array`** - list of all the transaction objects from the corresponding hashes.\n\n---\n\n### `getLatestInclusion`\n\nWrapper function for `getNodeInfo` and `getInclusionStates`. It simply takes the most recent solid milestone as returned by getNodeInfo, and uses it to get the inclusion states of a list of transaction hashes.\n\n\n#### Input\n```\niota.api.getLatestInclusion(hashes, callback)\n```\n\n1. **`hashes`**: `Array` List of transaction hashes\n2. **`callback`**: `Function` callback.\n\n#### Return Value\n\n1. **`Array`** - list of all the inclusion states of the transaction hashes\n\n---\n\n### `broadcastAndStore`\n\nWrapper function for `broadcastTransactions` and `storeTransactions`.\n\n#### Input\n```\niota.api.broadcastAndStore(trytes, callback)\n```\n\n1. **`trytes`**: `Array` List of transaction trytes to be broadcast and stored. Has to be trytes that were returned from `attachToTangle`\n2. **`callback`**: `Function` callback.\n\n#### Return Value\n\n**`Object`** - empty object.\n\n---\n\n### `getNewAddress`\n\nGenerates a new address from a seed and returns the address. This is either done deterministically, or by providing the index of the new address to be generated.\n\n#### Input\n```\niota.api.getNewAddress(seed [, options], callback)\n```\n\n1. **`seed`**: `String` tryte-encoded seed. It should be noted that this seed is not transferred\n2. **`options`**: `Object` which is optional:\n  - **`index`**: `Int` If the index is provided, the generation of the address is not deterministic.\n  - **`checksum`**: `Bool` Adds 9-tryte address checksum\n  - **`total`**: `Int` Total number of addresses to generate.\n  - **`returnAll`**: `Bool` If true, it returns all addresses which were deterministically generated (until findTransactions returns null)\n3. **`callback`**: `Function` Optional callback.\n\n#### Returns\n**`String | Array`** - returns either a string, or an array of strings.\n\n---\n\n### `getInputs`\n\nGets all possible inputs of a seed and returns them with the total balance. This is either done deterministically (by genearating all addresses until `findTransactions` returns null for a corresponding address), or by providing a key range to use for searching through.\n\nYou can also define the minimum `threshold` that is required. This means that if you provide the `threshold` value, you can specify that the inputs should only be returned if their collective balance is above the threshold value.\n\n\n#### Input\n```\niota.api.getInputs(seed, [, options], callback)\n```\n\n1. **`seed`**: `String` tryte-encoded seed. It should be noted that this seed is not transferred\n2. **`options`**: `Object` which is optional:\n  - **`start`**: `int` Starting key index  \n  - **`end`**: `int` Ending key index\n  - **`threshold`**: `int` Minimum threshold of accumulated balances from the inputs that is requested\n4. **`callback`**: `Function` Optional callback.\n\n#### Return Value\n\n1. **`Object`** - an object with the following keys:\n    - **`inputs`** `Array` - list of inputs objects consisting of `address`, `balance` and `keyIndex`\n    - **`totalBalance`** `int` - aggregated balance of all inputs\n\n\n---\n\n### `prepareTransfers`\n\nMain purpose of this function is to get an array of transfer objects as input, and then prepare the transfer by **generating the correct bundle**, as well as **choosing and signing the inputs** if necessary (if it\'s a value transfer). The output of this function is an array of the raw transaction data (trytes).\n\nYou can provide multiple transfer objects, which means that your prepared bundle will have multiple outputs to the same, or different recipients. As single transfer object takes the values of: `address`, `value`, `message`, `tag`. The message and tag values are required to be tryte-encoded.\n\nFor the options, you can provide a list of `inputs`, that will be used for signing the transfer\'s inputs. It should be noted that these inputs (an array of objects) should have the provided `keyIndex` and `address` values:\n```\nvar inputs = [{\n    \'keyIndex\': //VALUE,\n    \'address\': //VALUE\n}]\n```\n\nThe library validates these inputs then and ensures that you have sufficient balance. The `address` parameter can be used to define the address to which a remainder balance (if that is the case), will be sent to. So if all your inputs have a combined balance of 2000, and your spending 1800 of them, 200 of your tokens will be sent to that remainder address. If you do not supply the `address`, the library will simply generate a new one from your seed.\n\n#### Input\n```\niota.api.prepareTransfers(seed, transfersArray [, options], callback)\n```\n\n1. **`seed`**: `String` tryte-encoded seed. It should be noted that this seed is not transferred\n2. **`transfersArray`**: `Array` of transfer objects:\n  - **`address`**: `String` 81-tryte encoded address of recipient\n  - **`value`**: `Int` value to be transferred.\n  - **`message`**: `String` tryte-encoded message to be included in the bundle.\n  - **`tag`**: `String` Tryte-encoded tag. Maximum value is 27 trytes.\n3. **`options`**: `Object` which is optional:\n  - **`inputs`**: `Array` List of inputs used for funding the transfer\n  - **`address`**: `String` if defined, this address will be used for sending the remainder value (of the inputs) to.\n4. **`callback`**: `Function` Optional callback.\n\n#### Return Value\n\n`Array` - an array that contains the trytes of the new bundle.\n\n---\n\n### `sendTrytes`\n\nWrapper function that does `attachToTangle` and finally, it broadcasts and stores the transactions.\n\n#### Input\n```\niota.api.sendTrytes(trytes, depth, minWeightMagnitude, callback)\n```\n\n1. **`trytes`** `Array` trytes\n2. **`depth`** `Int` depth value that determines how far to go for tip selection\n3. **`minWeightMagnitude`** `Int` minWeightMagnitude\n4. **`callback`**: `Function` Optional callback.\n\n#### Returns\n`Array` - returns an array of the transfer (transaction objects).\n\n---\n\n### `sendTransfer`\n\nWrapper function that basically does `prepareTransfers`, as well as `attachToTangle` and finally, it broadcasts and stores the transactions locally.\n\n#### Input\n```\niota.api.sendTransfer(seed, depth, minWeightMagnitude, transfers [, options], callback)\n```\n\n1. **`seed`** `String` tryte-encoded seed. If provided, will be used for signing and picking inputs.\n2. **`depth`** `Int` depth\n3. **`minWeightMagnitude`** `Int` minWeightMagnitude\n4. **`transfers`**: `Array` of transfer objects:\n  - **`address`**: `String` 81-tryte encoded address of recipient\n  - **`value`**: `Int` value to be transferred.\n  - **`message`**: `String` tryte-encoded message to be included in the bundle.\n  - **`tag`**: `String` 27-tryte encoded tag.\n5. **`options`**: `Object` which is optional:\n  - **`inputs`**: `Array` List of inputs used for funding the transfer\n  - **`address`**: `String` if defined, this address will be used for sending the remainder value (of the inputs) to.\n6. **`callback`**: `Function` Optional callback.\n\n\n#### Returns\n`Array` - returns an array of the transfer (transaction objects).\n\n---\n\n### `replayBundle`\n\nTakes a tail transaction hash as input, gets the bundle associated with the transaction and then replays the bundle by attaching it to the tangle.\n\n#### Input\n```\niota.api.replayBundle(transaction [, callback])\n```\n\n1. **`transaction`**: `String` Transaction hash, has to be tail.\n2. **`depth`** `Int` depth\n3. **`minWeightMagnitude`** `Int` minWeightMagnitude\n2. **`callback`**: `Function` Optional callback\n\n---\n\n### `broadcastBundle`\n\nTakes a tail transaction hash as input, gets the bundle associated with the transaction and then rebroadcasts the entire bundle.\n\n#### Input\n```\niota.api.broadcastBundle(transaction [, callback])\n```\n\n1. **`transaction`**: `String` Transaction hash, has to be tail.\n2. **`callback`**: `Function` Optional callback\n\n---\n\n### `getBundle`\n\nThis function returns the bundle which is associated with a transaction. Input has to be a tail transaction (i.e. currentIndex = 0). If there are conflicting bundles (because of a replay for example) it will return multiple bundles. It also does important validation checking (signatures, sum, order) to ensure that the correct bundle is returned.\n\n#### Input\n```\niota.api.getBundle(transaction, callback)\n```\n\n1. **`transaction`**: `String` Transaction hash of a tail transaction.\n2. **`callback`**: `Function` Optional callback\n\n#### Returns\n`Array` - returns an array of the corresponding bundle of a tail transaction. The bundle itself consists of individual transaction objects.\n\n---\n\n\n### `getTransfers`\n\nReturns the transfers which are associated with a seed. The transfers are determined by either calculating deterministically which addresses were already used, or by providing a list of indexes to get the addresses and the associated transfers from. The transfers are sorted by their timestamp. It should be noted that, because timestamps are not enforced in IOTA, that this may lead to incorrectly sorted bundles (meaning that their chronological ordering in the Tangle is different).\n\nIf you want to have your transfers split into received / sent, you can use the utility function `categorizeTransfers`\n\n#### Input\n```\ngetTransfers(seed [, options], callback)\n```\n\n1. **`seed`**: `String` tryte-encoded seed. It should be noted that this seed is not transferred\n2. **`options`**: `Object` which is optional:\n  - **`start`**: `Int` Starting key index for search\n  - **`end`**: `Int` Ending key index for search\n  - **`inclusionStates`**: `Bool` If True, it gets the inclusion states of the transfers.\n3. **`callback`**: `Function` Optional callback.\n\n#### Returns\n`Array` - returns an array of transfers. Each array is a bundle for the entire transfer.\n\n---\n\n### `getAccountData`\n\nSimilar to `getTransfers`, just a bit more comprehensive in the sense that it also returns the `balance` and `addresses` that are associated with your account (seed). This function is useful in getting all the relevant information of your account. If you want to have your transfers split into received / sent, you can use the utility function `categorizeTransfers`\n\n#### Input\n```\ngetAccountData(seed [, options], callback)\n```\n\n1. **`seed`**: `String` tryte-encoded seed. It should be noted that this seed is not transferred\n2. **`options`**: `Object` which is optional:\n  - **`start`**: `Int` Starting key index for search\n  - **`end`**: `Int` Ending key index for search\n3. **`callback`**: `Function` Optional callback.\n\n#### Returns\n`Object` - returns an object of your account data in the following format:\n```\n{\n    \'addresses\': [],\n    \'transfers\': [],\n    \'balance\': 0\n}\n```\n\n---\n\n## `iota.utils`\n\nAll utils function are done synchronously.\n\n---\n\n### `convertUnits`\n\nIOTA utilizes the Standard system of Units. See below for all available units:\n\n```\n\'i\'   :   1,\n\'Ki\'  :   1000,\n\'Mi\'  :   1000000,\n\'Gi\'  :   1000000000,\n\'Ti\'  :   1000000000000,\n\'Pi\'  :   1000000000000000\n```\n\n#### Input\n```\niota.utils.convertUnits(value, fromUnit, toUnit)\n```\n\n1. **`value`**: `Integer` Value to be converted\n2. **`fromUnit`**: `String` Current unit of the value. See above for the available units to utilize for conversion.\n2. **`toUnit`**: `String` Unit to convert the from value into.\n\n#### Returns\n`Integer` - returns the converted unit (fromUnit => toUnit).\n\n---\n\n### `addChecksum`\n\nTakes an 81-trytes address or a list of addresses as input and calculates the 9-trytes checksum of the address(es).\n\n#### Input\n```\niota.utils.addChecksum(address)\n```\n\n1. **`address`**: `String | List` Either an individual address, or a list of addresses.\n\n#### Returns\n`String | List` - returns the 90-trytes addresses (81-trytes address + 9-trytes checksum) either as a string or list, depending on the input.\n\n---\n\n### `noChecksum`\n\nTakes an 90-trytes address as input and simply removes the checksum.\n\n#### Input\n```\niota.utils.noChecksum(address)\n```\n\n1. **`address`**: `String | List` 90-trytes address. Either string or a list\n\n#### Returns\n`String | List` - returns the 81-tryte address(es)\n\n---\n\n### `isValidChecksum`\n\nTakes an 90-trytes checksummed address and returns a true / false if it is valid.\n\n#### Input\n```\niota.utils.isValidChecksum(addressWithChecksum)\n```\n\n1. **`addressWithChecksum`**: `String` 90-trytes address  \n\n#### Returns\n`Bool` - True / False whether the checksum is valid or not\n\n---\n\n### `transactionObject`\n\nConverts the trytes of a transaction into its transaction object.\n\n#### Input\n```\niota.utils.transactionObject(trytes)\n```\n\n1. **`trytes`**: `String` 2673-trytes of a transaction  \n\n#### Returns\n`Object` - Transaction object\n\n---\n\n### `transactionTrytes`\n\nConverts a valid transaction object into trytes. Please refer to [TODO] for more information what a valid transaction object looks like.\n\n#### Input\n```\niota.utils.transactionTrytes(transactionObject)\n```\n\n1. **`transactionObject`**: `Object` valid transaction object  \n\n#### Returns\n`trytes` - converted trytes of\n\n---\n\n### `categorizeTransfers`\n\nCategorizes a list of transfers into `sent` and `received`. It is important to note that zero value transfers (which for example, is being used for storing addresses in the Tangle), are seen as `received` in this function.\n\n#### Input\n```\niota.utils.categorizeTransfers(transfers, addresses)\n```\n\n1. **`transfers`**: `List` A list of bundles. Basically is an array, of arrays (bundles), as is returned from getTransfers or getAccountData\n2. **`addresses`**: \'List\' List of addresses that belong to you. With these addresses as input, it\'s determined whether it\'s a sent or a receive transaction.\n\n#### Returns\n`object` - the transfers categorized into `sent` and `received`\n\n---\n\n\n## `iota.validate`\n\nValidator functions. Return either true / false.\n\n---\n\n### `isAddress`\n\nChecks if the provided input is a valid 81-tryte (non-checksum), or 90-tryte (with checksum) address.\n\n#### Input\n```\niota.validate.isAddress(address)\n```\n\n1. **`address`**: `String` A single address\n\n---\n\n### `isTrytes`\n\nDetermines if the provided input is valid trytes. Valid trytes are: `ABCDEFGHIJKLMNOPQRSTUVWXYZ9`. If you specify the length parameter, you can also validate the input length.\n\n#### Input\n```\niota.validate.isTrytes(trytes [, length])\n```\n\n1. **`trytes`**: `String`\n2. **`length`**: `int || string` optional\n\n---\n\n### `isValue`\n\nValidates the value input, checks if it\'s decimal number and an integer.\n\n#### Input\n```\niota.validate.isValue(value)\n```\n\n1. **`value`**: `Integer`\n\n---\n\n### `isHash`\n\nChecks if correct hash consisting of 81-trytes.\n\n#### Input\n```\niota.validate.isHash(hash)\n```\n\n1. **`hash`**: `String`\n\n---\n\n### `isTransfersArray`\n\nChecks if it\'s a correct array of transfer objects. A transfer object consists of the following values:\n```\n{\n    \'address\': // STRING (trytes encoded, 81 or 90 trytes)\n    \'value\': // INT\n    \'mesage\': // STRING (trytes encoded)\n    \'tag\': // STRING (trytes encoded, maximum 27 trytes)\n}\n```\n\n#### Input\n```\niota.validate.isTransfersArray(transfersArray)\n```\n\n1. **`transfersArray`**: `array`\n\n---\n\n### `isArrayOfHashes`\n\nArray of valid 81 or 90-trytes hashes.\n\n#### Input\n```\niota.validate.isArrayOfHashes(hashesArray)\n```\n\n1. **`hashesArray`**: `Array`\n\n---\n\n### `isArrayOfTrytes`\n\nChecks if it\'s an array of correct 2673-trytes. These are trytes either returned by prepareTransfers, attachToTangle or similar call. A single transaction object is encoded 2673 trytes.\n\n#### Input\n```\niota.validate.isArrayOfTrytes(trytesArray)\n```\n\n1. **`trytesArray`**: `Array`\n\n---\n\n### `isArrayOfAttachedTrytes`\n\nSimilar to `isArrayOfTrytes`, just that in addition this function also validates that the last 243 trytes are non-zero (meaning that they don\'t equal 9). The last 243 trytes consist of:  `trunkTransaction` + `branchTransaction` + `nonce`. As such, this function determines whether the provided trytes have been attached to the tangle successfully. For example this validator can be used for trytes returned by `attachToTangle`.\n\n#### Input\n```\niota.validate.isArrayOfAttachedTrytes(trytesArray)\n```\n\n1. **`trytesArray`**: `Array`\n\n---\n\n### `isUri`\n\nWork in progress. If this is still here while you\'re reading the documentation, tell either Dominik or someone else from Core to move their asses.\n\n#### Input\n```\niota.validate.isUri(uris)\n```\n\n1. **`uris`**: `Array`\n\n---\n\n### `isInputs`\n\nValidates if it\'s an array of correct input objects. These inputs are provided to either `prepareTransfers` or `sendTransfer`. An input objects consists of the following:\n\n```\n{\n    \'keyIndex\': // INT\n    \'address\': // STRING\n}\n```\n\n#### Input\n```\niota.validate.isInputs(inputsArray)\n```\n\n1. **`inputsArray`**: `Array`\n\n---\n\n### `isString`\n\nSelf explanatory.\n\n#### Input\n```\niota.validate.isString(string)\n```\n\n---\n\n### `isInt`\n\nSelf explanatory.\n\n#### Input\n```\niota.validate.isInt(int)\n```\n\n---\n\n### `isArray`\n\nSelf explanatory.\n\n#### Input\n```\niota.validate.isArray(array)\n```\n\n---\n\n### `isObject`\n\nSelf explanatory.\n\n#### Input\n```\niota.validate.isObject(array)\n```\n',
21 silly publish   readmeFilename: 'README.md',
21 silly publish   gitHead: 'e65d2248bdabe705603691da21ed271a88a7dfc4',
21 silly publish   homepage: 'https://github.com/iotaledger/iota.lib.js#readme',
21 silly publish   _id: 'iota.lib.js@0.0.11',
21 silly publish   _shasum: '68cb24102938c8d4794eaab164f66dfe8a7ca61f',
21 silly publish   _from: '.' }
22 verbose getPublishConfig undefined
23 silly mapToRegistry name iota.lib.js
24 silly mapToRegistry using default registry
25 silly mapToRegistry registry https://registry.npmjs.org/
26 silly mapToRegistry data Result {
26 silly mapToRegistry   raw: 'iota.lib.js',
26 silly mapToRegistry   scope: null,
26 silly mapToRegistry   name: 'iota.lib.js',
26 silly mapToRegistry   rawSpec: '',
26 silly mapToRegistry   spec: 'latest',
26 silly mapToRegistry   type: 'tag' }
27 silly mapToRegistry uri https://registry.npmjs.org/iota.lib.js
28 verbose publish registryBase https://registry.npmjs.org/
29 silly publish uploading /Users/domsch/.npm/iota.lib.js/0.0.11/package.tgz
30 verbose request uri https://registry.npmjs.org/iota.lib.js
31 verbose request sending authorization for write operation
32 info attempt registry request try #1 at 1:36:41 PM
33 verbose request using bearer token for auth
34 verbose request id 75986be1518328c8
35 http request PUT https://registry.npmjs.org/iota.lib.js
36 http 403 https://registry.npmjs.org/iota.lib.js
37 verbose headers { 'content-type': 'application/json',
37 verbose headers   'cache-control': 'max-age=300',
37 verbose headers   'content-length': '96',
37 verbose headers   'accept-ranges': 'bytes',
37 verbose headers   date: 'Wed, 14 Dec 2016 12:36:47 GMT',
37 verbose headers   via: '1.1 varnish',
37 verbose headers   connection: 'keep-alive',
37 verbose headers   'x-served-by': 'cache-fra1226-FRA',
37 verbose headers   'x-cache': 'MISS',
37 verbose headers   'x-cache-hits': '0',
37 verbose headers   'x-timer': 'S1481719002.298960,VS0,VE4957',
37 verbose headers   vary: 'Accept-Encoding' }
38 verbose request invalidating /Users/domsch/.npm/registry.npmjs.org/iota.lib.js on PUT
39 error publish Failed PUT 403
40 verbose stack Error: "You cannot publish over the previously published version 0.0.11." : iota.lib.js
40 verbose stack     at makeError (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:264:12)
40 verbose stack     at CachingRegistryClient.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:252:14)
40 verbose stack     at Request._callback (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:172:14)
40 verbose stack     at Request.self.callback (/usr/local/lib/node_modules/npm/node_modules/request/request.js:200:22)
40 verbose stack     at emitTwo (events.js:87:13)
40 verbose stack     at Request.emit (events.js:172:7)
40 verbose stack     at Request.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:1067:10)
40 verbose stack     at emitOne (events.js:82:20)
40 verbose stack     at Request.emit (events.js:169:7)
40 verbose stack     at IncomingMessage.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:988:12)
41 verbose statusCode 403
42 verbose pkgid iota.lib.js
43 verbose cwd /Users/domsch/Desktop/IOTA/iota.lib.js
44 error Darwin 15.6.0
45 error argv "/usr/local/bin/node" "/usr/local/bin/npm" "publish"
46 error node v4.2.1
47 error npm  v3.9.5
48 error code E403
49 error "You cannot publish over the previously published version 0.0.11." : iota.lib.js
50 error If you need help, you may report this error at:
50 error     <https://github.com/npm/npm/issues>
51 verbose exit [ 1, true ]
